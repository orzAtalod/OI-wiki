author: Ir1d, ShadowsEpic, Fomalhauthmj, siger-young, MingqiHuang, Xeonacid, hsfzLZH1, orzAtalod

倍增法，通过字面意思来看就是翻倍。这个方法在很多算法中均有应用，其中最常用的就是 RMQ 问题和求 LCA 了。

## 例题

> 给出一个长度为 `n` 的环和一个常数 `k` ，第 `i` 个点会跳到第 `(i+k)%n+1` 个点，总共跳了 `m` 次。每个点都有一个权值，记为 $a_i$，可正可负，初始时权值为 `0` ，求 `m` 次跳跃之后的总权值。
>
> 数据范围，$1\leq n\leq 10^6,1\leq m\leq 10^{18},1\leq k<n$

这里，显然不能暴力模拟跳 `m` 次。因为 `m` 最大可到 $10^{18}$ 级别，如果暴力模拟的话，时间承受不住。

所以，就需要进行一些预处理，提前整合一些信息，以便于在查询的时候更快得出结果。如果记录下来每一个可能的跳跃次数的结果的话，不论是时间还是空间都难以承受。

那么，应该如何预处理呢？先看一道其他例题：

> 如何用尽可能少的砝码称量出 `0-31` 之间的所有重量？（只能在天平的一端放砝码）

答案是，使用 `1 2 4 8 16` 这五个砝码，可以称量出 `0-31` 之间的所有重量。同样，如果要称量 `0-127` 之间的所有重量，可以使用 `1 2 4 8 16 32 64` 这七个砝码。每次，我们都选择 `2` 的整次幂作砝码的重量，就可以使用极少的砝码个数量出任意我们所需要的重量。

为什么说是极少呢？因为，如果我们要量出 `0-1023` 之间的所有重量，只需要 `9` 个砝码，需要量出 `0-1048575` 之间的所有重量，只需要 `19` 个。如果我们的目标重量翻倍，砝码个数只需要增加 `1` 。这叫 `对数级` 的增长速度，因为砝码的所需个数与目标重量的范围的对数成正比。

回到上面的题。我们要预处理一些信息，然后用预处理的信息尽量快的整合出答案。同时，预处理的信息也不能太多。所以，可以预处理出以 `2` 的整次幂为单位的信息，这样的话，在预处理的时候只需要处理少量信息，在整合的时候也不需要大费周章。

在这题上，就是我们预处理出从每个点开始跳 `1` 、`2` 、`4` 、`8` 等等步之后的结果（所处点和点权和），然后如果要跳 `13` 步，只需要跳 `1+4+8` 步就好了。也就是说，先在起始点跳 `1` 步，然后再在跳了之后的终点跳 `4` 步，再接着跳 `8` 步，同时统计一下预先处理好的点权和，就可以知道跳 `13` 步的点权和了。

对于每一个点开始的 $2^i$ 步，记录一个 `go[i][x]` 表示第 `x` 个点跳 $2^i$ 步之后的终点，而 `sum[i][x]` 表示第 `x` 个点跳 $2^i$ 步之后能获得的点权和。预处理的时候，开两重循环，对于跳 $2^i$ 步的信息，我们可以看作是先跳了 $2^{i-1}$ 步，再跳 $2^{i-1}$ 步，因为显然有 $2^{i-1}+2^{i-1}=2^i$ 。即我们有 `sum[i][x] = sum[i-1][x]+sum[i-1][go[i-1][x]]`，且 `go[i][x] = go[i-1][go[i-1][x]]` 。

当然，还有一些实现细节需要注意。为了保证统计的时候不重不漏，我们一般预处理出 `左闭右开` 的点权和。亦即，对于跳 `1` 步的情况，我们只记录该点的点权和；对于跳 `2` 步的情况，我们只记录该点及其下一个点的点权和。相当于，总是不将终点的点权和计入 `sum` 。这样，在预处理的时候，只需要将两部分的点权和直接相加就可以了，不需要担心第一段的终点和第二段的起点会被重复计算。

这题的 $m\leq 10^{18}$ ，虽然看似恐怖，但是实际上只需要预处理出 `65` 以内的 `i`，就可以轻松解决，比起暴力枚举快了很多。用行话讲，这个做法的 [时间复杂度]( https://oi-wiki.org/misc/complexity/ ) 是预处理 $\Theta(n\log m)$，查询每次 $\Theta(\log m)$ 。

倍增除了作为一种独立的思想以外，还经常被应用到各种算法里面，例如 `LCA` 和 `RMQ` 问题，可以在下面查看。

## RMQ 问题

RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。

使用倍增解决 RMQ 问题的方法就是 [ST 表](/ds/sparse-table) ，除了 ST 表，还有 [线段树](/ds/seg) 也可以解决 RMQ 问题。

## 树上倍增求 LCA

具体请参见 [最近公共祖先](/graph/lca/#_5) 页面。
